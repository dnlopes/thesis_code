package database.invariants;

import database.util.DataField;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.update.Update;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import runtime.operation.ShadowOperation;
import util.ExitCode;

/**
 * Created by dnlopes on 17/03/15.
 */
public class InvariantChecker
{

	static final Logger LOG = LoggerFactory.getLogger(InvariantChecker.class);

	public static void checkInvariant(ShadowOperation shadowOp, Statement stat, DataField field, String value)
	{
		LOG.trace("checking for invariants for field {}", field.getFieldName());

		if(stat == null || !field.hasInvariants())
			return;

		if(stat instanceof Insert)
			checkInvariantsForInsert(shadowOp, (Insert) stat, field, value);

		if(stat instanceof Update)
			checkInvariantsForUpdate(shadowOp, (Update) stat, field);
		if(stat instanceof Delete)
			checkInvariantsForDelete(shadowOp, (Delete) stat, field);
	}

	public static void checkInvariantsForInsert(ShadowOperation shadowOp, Insert stat, DataField field, String value)
	{
		// unique (only if generated by user)
		// check constraints (not implemented in MySQL)

		for(Invariant inv : field.getInvariants())
		{
			if(inv instanceof UniqueInvariant)
			{
				LOG.trace("checking unique constraint to field {} with value {}", field.getFieldName(), value);
				FieldValuePair pair = new FieldValuePair(field,value);
				shadowOp.addInvariant(inv,pair);

				//TODO create an entry in ShadowOp to send to coordinator
			} else if(inv instanceof GreaterThanInvariant)
			{
				if(((GreaterThanInvariant) inv).isViolated(value))
				{
					LOG.warn("constraint violated: trying to insert {} for field {}", value,
							field.getFieldName());
					shadowOp.setInternalAborted();
				}
			} else if(inv instanceof LesserThanInvariant)
			{

				if(((LesserThanInvariant) inv).isViolated(value))
				{
					LOG.warn("constraint violated: trying to insert {} for field {}", value,
							field.getFieldName());
					shadowOp.setInternalAborted();
				}
			}
			else {
				LOG.error("Unkown Invariant type. Exiting.");
				runtime.Runtime.throwRunTimeException("unknown invariant type", ExitCode.UNKNOWN_INVARIANT);
			}
		}

	}

	public static void checkInvariantsForUpdate(ShadowOperation shadowOp, Update stat, DataField field)
	{
		//check uniques, and check
	}

	public static void checkInvariantsForDelete(ShadowOperation shadowOp, Delete stat, DataField field)
	{
		//TODO
		// maybe we should contact the coordinator to free "unique" names that will be free after delete?
	}

	private static void checkUniqueInvariant(UniqueInvariant inv, DataField field)
	{

	}
}
