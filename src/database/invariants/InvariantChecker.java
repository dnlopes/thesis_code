package database.invariants;

import database.util.DataField;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.update.Update;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import runtime.operation.ShadowOperation;
import runtime.Runtime;
import util.ExitCode;


/**
 * Created by dnlopes on 17/03/15.
 */
public class InvariantChecker
{

	static final Logger LOG = LoggerFactory.getLogger(InvariantChecker.class);

	public static void checkInvariants(ShadowOperation shadowOp, Statement stat, DataField field, String value)
	{
		LOG.trace("checking for invariants for field {}", field.getFieldName());

		if(stat == null || !field.hasInvariants())
			return;

		if(stat instanceof Insert)
			checkInvariantsForInsert(shadowOp, field, value);
		if(stat instanceof Update)
			checkInvariantsForUpdate(shadowOp, (Update) stat, field, value);
		if(stat instanceof Delete)
			checkInvariantsForDelete(shadowOp, (Delete) stat, field);
	}

	public static void checkInvariantsForInsert(ShadowOperation shadowOp, DataField field, String value)
	{
		// unique (only if generated by user)
		// autoincrement is not included because it
		// check constraints (not implemented in MySQL)
		// no need to verify delta here because it is an insert op

		for(Invariant inv : field.getInvariants())
		{
			if(inv instanceof UniqueInvariant)
			{
				FieldValuePair pair;
				if(field.isAutoIncrement())
				{
					pair = new FieldValuePair(field, null);
					LOG.trace("autoincrement constraint to field {}. Requesting value to coordinator",
							field.getFieldName());
				} else
				{
					LOG.trace("unique constraint to field {} with desired value {}", field.getFieldName(), value);
					pair = new FieldValuePair(field, value);
				}

				shadowOp.addInvariant(inv, pair);

			} else if(inv instanceof GreaterThanInvariant)
			{
				if(((GreaterThanInvariant) inv).isViolated(value))
				{
					LOG.warn("constraint violated: trying to insert {} for field {}", value, field.getFieldName());
					shadowOp.setInternalAborted();
				}
			} else if(inv instanceof LesserThanInvariant)
			{

				if(((LesserThanInvariant) inv).isViolated(value))
				{
					LOG.warn("constraint violated: trying to insert {} for field {}", value, field.getFieldName());
					shadowOp.setInternalAborted();
				}
			} else
			{
				LOG.error("Unkown Invariant type. Exiting.");
				Runtime.throwRunTimeException("unknown invariant type", ExitCode.UNKNOWN_INVARIANT);
			}
		}

	}

	public static void checkInvariantsForUpdate(ShadowOperation shadowOp, Update stat, DataField field, String value)
	{
		//check uniques, and check
		//TODO
	}

	public static void checkInvariantsForDelete(ShadowOperation shadowOp, Delete stat, DataField field)
	{
		//TODO
		// maybe we should contact the coordinator to free "unique" names that will be free after delete?
	}
}
