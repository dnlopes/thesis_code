package database.invariants;


import database.jdbc.util.DBOperationType;
import database.util.DataField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import runtime.RuntimeHelper;
import util.ExitCode;

import java.util.List;


/**
 * Created by dnlopes on 17/03/15.
 */
public class InvariantChecker
{

	static final Logger LOG = LoggerFactory.getLogger(InvariantChecker.class);

	public static void checkInvariants(DBOperationType opType, DataField field, String value,
									   List<CheckInvariantItem> invariantsList)
	{
		LOG.trace("checking for invariants for field {}", field.getFieldName());

		if(opType == DBOperationType.INSERT)
			checkInvariantsForInsert(field, value, invariantsList);
		if(opType == DBOperationType.UPDATE)
			checkInvariantsForUpdate(field, value, invariantsList);
		if(opType == DBOperationType.DELETE)
			checkInvariantsForDelete(field, value, invariantsList);
	}


	public static void checkInvariantsForInsert(DataField field, String value, List<CheckInvariantItem> invariantList)
	{
		// unique (only if generated by user)
		// autoincrement is not included because it
		// check constraints (not implemented in MySQL)
		// no need to verify delta here because it is an insert op

		for(Invariant inv : field.getInvariants())
		{
			if(inv.getType() == InvariantType.UNIQUE)
			{
				if(field.isAutoIncrement())
				{
					//RequestValue requestValue = new RequestValue(field.getTableName(), field.getFieldName());
					//invariantList.add(requestValue);
					LOG.trace("autoincrement constraint in field {}. Will request value to coordinator",
							field.getFieldName());

				} else
				{
					//UniqueValue checkValue = new UniqueValue(field.getTableName(), field.getFieldName(), value);
					LOG.trace("unique constraint in field {} with desired value {}", field.getFieldName(), value);
					//invariantList.add(checkValue);
				}

			} else if(inv.getType() == InvariantType.GREATHER_THAN)
			{
				if(((GreaterThanInvariant) inv).isViolated(value))
				{
					LOG.error("constraint violated: trying to insert {} in field {}", value, field.getFieldName());
				}
			} else if(inv.getType() == InvariantType.LESSER_THAN)
			{

				if(((LesserThanInvariant) inv).isViolated(value))
				{
					LOG.error("constraint violated: trying to insert {} in field {}", value, field.getFieldName());
				}
			} else
			{
				LOG.error("Unkown Invariant type. Exiting.");
				RuntimeHelper.throwRunTimeException("unknown invariant type", ExitCode.UNKNOWN_INVARIANT);
			}
		}

	}

	public static void checkInvariantsForUpdate(DataField field, String value, List<CheckInvariantItem> invariantList)
	{
		//FIXME: same logic for inserts and updates?
		checkInvariantsForInsert(field, value, invariantList);
	}

	public static void checkInvariantsForDelete(DataField field, String value, List<CheckInvariantItem> invariantList)
	{

		//TODO: implement
		// we should contact the coordinator to free "unique" names that will be free after delete
		// CHECK constraints are not relevant in this case
		// what if this check constraint involves other tuples?
		// here we only care about unique values that will be freed by the operation
		// we should not care about autoincrement as well

	}

	public static boolean checkValueForField(DataField field, String value)
	{

		if(!field.hasInvariants())
			return true;

		for(Invariant inv : field.getInvariants())
		{
			if(inv.getType() == InvariantType.GREATHER_THAN || inv.getType() == InvariantType.LESSER_THAN)
				if(!checkInvariantForField(field, value, inv))
					return false;
		}

		return true;
	}

	private static boolean checkInvariantForField(DataField field, String value, Invariant inv)
	{
		boolean isValid = true;

		if(inv.getType() == InvariantType.GREATHER_THAN)
		{
			if(((GreaterThanInvariant) inv).isViolated(value))
				isValid = false;
		} else if(inv.getType() == InvariantType.LESSER_THAN)
		{
			if(((GreaterThanInvariant) inv).isViolated(value))
				isValid = false;
		}

		return isValid;
	}
}
